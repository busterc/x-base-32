{"version":3,"sources":["../lib/xBase32.js"],"names":[],"mappings":"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","file":"xbase32.min.js","sourcesContent":["'use strict';\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n\nconst dict = '0123456789abcdefghjkmnpqrstvwxyz'.split('');\nconst pad32 = '00000000000000000000000000000000'; // 32 bits\nconst pad5 = '00000';\n\nfunction encode(src) {\n  let byteSizeMin = 8;\n  let byteSize = byteSizeMin;\n  let bin = '';\n  let checkSymbol = new CheckSymbol();\n\n  // Create a string of padded bits\n  src.split('').forEach(c => {\n    let cp = c.codePointAt(0);\n    let cc = cp.toString(2);\n    byteSize = cc.length > byteSize ? cc.length : byteSize;\n    let ccPadded = (pad32 + cc).slice(-pad32.length);\n    bin += ccPadded;\n  });\n\n  // Trim bytes to actual byteSize\n  bin = bin\n    .match(/.{1,32}/g)\n    .map(b => {\n      let byte = b.slice(-byteSize);\n      let cp = parseInt(byte, 2);\n      checkSymbol.update(cp);\n      return byte;\n    })\n    .join('');\n\n  // Encode every 5 bits (base32)\n  let bytes = bin.match(/.{1,5}/g);\n  let encoded = '';\n  bytes.forEach(b => {\n    if (b.length === 5) {\n      let n = parseInt(b, 2);\n      encoded += dict[n];\n      return;\n    }\n    // Pad last byte, when there is one\n    let padded = (b + pad5).substr(0, pad5.length);\n    let n = parseInt(padded, 2);\n    encoded += dict[n];\n  });\n\n  // Add byteSize prefix for decoding\n  encoded = dict[byteSize] + encoded;\n\n  // Add checkSymbol suffix\n  encoded += checkSymbol.get();\n  return encoded;\n}\n\nfunction decode(encoded) {\n  let checkSymbol = new CheckSymbol();\n\n  encoded = normalize(encoded);\n\n  // Get byteSize from prefix\n  encoded = encoded.split('');\n  let byteSize = encoded.shift();\n  byteSize = dict.indexOf(byteSize);\n\n  // Get the checkSymbol from suffix\n  let expectedCheckSymbol = encoded.pop();\n\n  // Parse out the string of bits\n  let decodedBin = '';\n  encoded.forEach(c => {\n    let n = dict.indexOf(c);\n    let bits = parseInt(n, 10).toString(2);\n    let paddedBits = (pad5 + bits).slice(-pad5.length);\n    decodedBin += paddedBits;\n  });\n\n  // Decode every *byteSize byte\n  let bytes = decodedBin.match(new RegExp(`.{1,${byteSize}}`, 'g'));\n  let decoded = '';\n  bytes.forEach(b => {\n    let cp = parseInt(parseInt(b, 2), 10); // .toString(10);\n    if (b.length === byteSize) {\n      checkSymbol.update(cp);\n      let char = String.fromCodePoint(cp);\n      decoded += char;\n    }\n  });\n\n  if (expectedCheckSymbol !== checkSymbol.get()) {\n    throw Error('Failed to Pass Validation Check');\n  }\n  return decoded;\n}\n\nfunction normalize(encoded) {\n  let normalized = '';\n  encoded = encoded.replace(/[il]/gi, 1).replace(/[o]/gi, 0);\n  encoded.split('').forEach(c => {\n    if (dict.indexOf(c) > -1) {\n      normalized += c;\n    }\n  });\n  return normalized;\n}\n\nfunction CheckSymbol() {\n  let currentMod = 0;\n  let symbol = '';\n\n  function update(codePoint) {\n    currentMod = (currentMod + codePoint) % 32;\n    symbol = dict[currentMod];\n  }\n\n  function get() {\n    return symbol;\n  }\n  return {\n    update: update,\n    get: get\n  };\n}\n"]}